## Sliding window log vs sliding windo counter

好的，这是一个非常高级的系统设计问题，也是面试中的经典考点。这两个算法都是为了解决“固定窗口算法”的临界问题，但它们的实现方式和权衡取舍完全不同。

你提到了 **Sliding Window Log**，我们就从它开始。

---

### 比喻：精确的入场记录 vs. 估算人数

想象一下，你在为一个博物馆的特别展厅设计限流规则：“任意60分钟内，都不能有超过100人进入。”

*   **Sliding Window Log (精确的日志记录)**: 你雇了一个保安，他手里有一个日志本。**每进去一个人，他就在本子上记下这个人进入的精确时间戳**（例如 `10:30:15`）。当有人想进来时，保安会翻看日志，去掉所有1小时前的时间戳，然后数一下本子上还剩多少条记录。如果少于100条，就放新人进去并记下新的时间戳。
    *   **优点**: 绝对精确。任何时候你问他，他都能告诉你过去60分钟内到底进来了多少人。
    *   **缺点**: 如果人流量很大（每秒1000人），这个日志本会变得非常巨大，保安数起来也会很慢。

*   **Sliding Window Counter (估算的计数器)**: 你给了保安**两个**手持计数器。一个记录“当前小时”（例如10:00-11:00）的人数，另一个记录“上一个小时”（例如09:00-10:00）的人数。
    *   当 `10:30:15` 有人想进来时，保安会这样**估算**过去60分钟的人数：`(上一个小时的人数 * 剩余的权重) + 当前小时的人数`。
    *   在10点半时，上一个小时还剩30分钟的参考价值，所以权重是 `50%`。估算值 = `(09:00-10:00的总人数 * 50%) + (10:00到现在的人数)`。
    *   **优点**: 非常节省资源。保安只需要维护两个数字，不需要巨大的日志本。
    *   **缺点**: 这是个**估算值**，不是精确值。它假设上一个小时的人流是均匀分布的，但事实可能并非如此（可能所有人都集中在前半小时进来）。

---

### 详细技术对比

| 特性 | Sliding Window Log | Sliding Window Counter (Hybrid) |
| :--- | :--- | :--- |
| **核心思想** | 记录**每个请求的精确时间戳**。 | 维护**两个固定时间窗口的计数器**（当前窗口和前一个窗口），并根据当前时间在窗口中的位置进行加权计算。 |
| **数据结构 (Redis)** | **Sorted Set (有序集合)**。`ZADD` 记录请求，`score` 是时间戳。 | **两个独立的 Key-Value** 或一个 Hash。`INCR` 增加计数。 |
| **准确性** | **100% 精确**。因为存储了所有相关数据，所以计数永远是准确的。 | **近似精确**。它假设前一个窗口的流量是均匀分布的，这在现实中通常不是真的，因此存在误差。 |
| **内存占用** | **高**。需要为时间窗口内的**每一个请求**都存储一个条目。如果请求量巨大，内存消耗会非常显著。 | **极低 (常量级)**。无论请求量多大，永远只需要存储两个计数器和它们的时间戳。 |
| **性能/计算复杂度** | **较高**。每次请求都需要执行多个Redis命令 (`ZADD`, `ZREMRANGEBYSCORE`, `ZCARD`)，操作的是一个可能很大的集合。复杂度为 O(log N)。 | **极高**。只需要 `GET` 两个 key 和执行一次 `INCR`。复杂度为 O(1)。 |
| **实现复杂度** | 概念上简单，逻辑直接。 | 稍复杂，需要处理窗口切换的逻辑和**加权平均**的计算。 |

---

### 两种算法的实现细节

#### Sliding Window Log (使用 Redis Sorted Set)

假设限流规则是：每分钟最多100个请求。

1.  当一个请求到达时，使用 `MULTI` 开启 Redis 事务。
2.  **移除旧记录**: 使用 `ZREMRANGEBYSCORE` 命令，移除所有 `score` (时间戳) 小于 `(当前时间戳 - 60秒)` 的成员。这步操作清除了窗口之外的所有旧请求记录。
3.  **添加当前请求**: 使用 `ZADD` 将当前请求的时间戳作为 `score` 添加到集合中。
4.  **获取当前窗口大小**: 使用 `ZCARD` 获取集合中的成员数量。
5.  提交事务 `EXEC`。
6.  **决策**: 比较获取到的数量和阈值100。如果小于100，则允许请求；否则，拒绝。

```
# 伪代码
key = "rate_limit_log:user123"
now = current_timestamp_ms()
window = 60000 # 60 seconds in ms

# 使用 Lua 脚本保证原子性
EVAL "
  redis.call('ZREMRANGEBYSCORE', KEYS[1], 0, ARGV[1])
  redis.call('ZADD', KEYS[1], ARGV[2], ARGV[2])
  return redis.call('ZCARD', KEYS[1])
" 1 key (now - window) now
```

#### Sliding Window Counter (使用 Redis Key-Value)

假设限流规则是：每分钟最多100个请求。

1.  获取**当前分钟**的计数器 `count_current` 和**前一分钟**的计数器 `count_previous`。
2.  获取当前时间在当前分钟内的**位置百分比**。例如，`10:30:15` 是在 `10:30` 这一分钟的 `25%` (15秒/60秒) 的位置。
3.  **计算估算值**:
    *   前一个窗口的权重 = `100% - 25% = 75%`
    *   估算总数 = `(count_previous * 75%) + count_current`
4.  **决策**:
    *   如果 `估算总数 < 100`，则允许请求，并对 `count_current` 执行 `INCR`。
    *   否则，拒绝请求。

### 总结：何时选择哪一个？

这个选择完全取决于你的业务需求和对成本的考量。

**选择 Sliding Window Log，当你需要：**
*   **绝对的精确性**：比如用于计费的API调用、金融交易、防止重复提交等“一次都不能错”的场景。
*   **请求量可控**：当你知道用户的请求频率不会高到让 Redis 内存爆炸时。对于限制非常严格（如每小时10次）的场景，这个算法非常完美。

**选择 Sliding Window Counter，当你需要：**
*   **极高的内存效率和性能**：这是它最大的优点。用于需要处理海量请求（每秒上万甚至几十万）的场景，比如大型网站的入口流量、防止DDoS攻击、通用的API滥用防护。
*   **可以容忍微小误差**：对于防止暴力破解、爬虫等场景，多放或少放几个请求无关紧要，只要能挡住绝大部分攻击即可。在这种场景下，为了一点点精度而牺牲巨大的内存和性能是得不偿失的。

在绝大多数大型互联网公司的实践中，**Sliding Window Counter 及其变体是更为主流的选择**，因为它在成本和效果之间取得了最佳的平衡。