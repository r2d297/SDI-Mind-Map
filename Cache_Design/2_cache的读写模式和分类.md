cache aside 旁路缓存
read/write through 读写穿透缓存
write behind caching  异步缓存写入



![alt text](image-6.png)
写: 更新db,删除cache, db驱动cache update
业务端处理所有访问细节, 大幅降低数据不一致概率,缓存数据更新比较复杂的业务; 使用一个trigger组件,实时读取db changes来更新缓存
业务端需要同时维护cache和update,过于繁琐,于是就有了read-write through

![alt text](image-7.png)
存储服务负责cache层所有处理,系统隔离性好


![alt text](image-8.png)

![alt text](image-9.png)

1
00:00:00,000 --> 00:00:03,000
你好,我是你的缓存老师,陈波

2
00:00:03,000 --> 00:00:04,500
欢迎进入第二课室

3
00:00:04,500 --> 00:00:06,500
缓存的读写模式及分类

4
00:00:06,500 --> 00:00:11,500
这一课室,我们主要学习缓存的读写模式及缓存的分类

5
00:00:11,500 --> 00:00:14,500
业务应用系统读写缓存有三种方式

6
00:00:14,500 --> 00:00:16,500
分别cache aSIDE,旁路缓存

7
00:00:16,500 --> 00:00:18,500
Read/Write Through,读写穿透

8
00:00:18,500 --> 00:00:20,500
和Write Behind the Caching,异步缓存写入

9
00:00:20,500 --> 00:00:22,500
cache aSIDE模式中

10
00:00:22,500 --> 00:00:25,500
业务应用方对于写请求是在更新DB后

11
00:00:25,500 --> 00:00:28,500
直接将Key从cache中删除

12
00:00:28,500 --> 00:00:31,500
然后由DB驱动缓存数据的更新

13
00:00:31,500 --> 00:00:34,500
对读是先读Cache,如果cache没有,则读DB

14
00:00:34,500 --> 00:00:38,500
同时将DB中读取的数据回写回Cache再返回

15
00:00:38,500 --> 00:00:39,500
这种模式的特点是

16
00:00:39,500 --> 00:00:42,500
业务端处理所有数据访问细节

17
00:00:42,500 --> 00:00:44,500
并利用Lazy计算的思想

18
00:00:44,500 --> 00:00:47,500
更新DB时直接删除Cache

19
00:00:47,500 --> 00:00:49,500
最后通过DB数据驱动更新

20
00:00:49,500 --> 00:00:52,500
以确保数据以DB结果为准

21
00:00:52,500 --> 00:00:56,500
可以大幅降低Cache和DB中数据不一致的概率

22
00:00:56,500 --> 00:00:58,500
如果没有专门的存储服务

23
00:00:58,500 --> 00:01:01,500
同时对数据的一致性要求比较高的业务

24
00:01:01,500 --> 00:01:04,500
或者缓存数据更新比较复杂的业务

25
00:01:04,500 --> 00:01:06,500
都比较适合使用cache aSIDE模式

26
00:01:06,500 --> 00:01:08,500
如微博发展初期

27
00:01:08,500 --> 00:01:09,500
不少业务采用这种模式

28
00:01:09,500 --> 00:01:13,500
这些缓存数据通过多个原则数据进行计算后设置

29
00:01:13,500 --> 00:01:16,500
在部分数据变更后直接删除缓存

30
00:01:16,500 --> 00:01:18,500
同时使用一个trigger组件

31
00:01:18,500 --> 00:01:20,500
实时读取DB的变更日志

32
00:01:20,500 --> 00:01:22,500
然后重新计算并更新缓存

33
00:01:22,500 --> 00:01:24,500
如果读缓存的时候

34
00:01:24,500 --> 00:01:26,500
trigger还没有写入缓存数据

35
00:01:26,500 --> 00:01:29,500
则由调用方自行到DB加载计算

36
00:01:29,500 --> 00:01:31,500
对于开启SIDE模式

37
00:01:31,500 --> 00:01:33,500
业务应用需要同时维护

38
00:01:33,500 --> 00:01:36,500
Cache和DB两个数据存储方过于繁琐

39
00:01:36,500 --> 00:01:39,500
于是就有了read-write-through模式

40
00:01:39,500 --> 00:01:40,500
在这种模式下

41
00:01:40,500 --> 00:01:43,500
业务应用只关注一个存储服务即可

42
00:01:43,500 --> 00:01:45,500
业务方的读写Cache和DB的操作

43
00:01:45,500 --> 00:01:47,500
都由存储服务代理

44
00:01:47,500 --> 00:01:50,500
存储服务收到业务应用的写请求时

45
00:01:50,500 --> 00:01:51,500
会首先查Cache

46
00:01:51,500 --> 00:01:53,500
如果数据在Cache中不存在

47
00:01:53,500 --> 00:01:54,500
则只更新DB

48
00:01:54,500 --> 00:01:56,500
如果数据在Cache中存在

49
00:01:56,500 --> 00:01:58,500
则先更新Cache

50
00:01:58,500 --> 00:02:00,500
然后再更新DB

51
00:02:00,500 --> 00:02:02,500
而存储服务收到读请求时

52
00:02:02,500 --> 00:02:03,500
如果命中Cache

53
00:02:03,500 --> 00:02:04,500
则直接返回

54
00:02:04,500 --> 00:02:06,500
否则先从DB中加载

55
00:02:06,500 --> 00:02:08,500
回中Cache后返回响应

56
00:02:08,500 --> 00:02:09,500
这种模式的特点是

57
00:02:09,500 --> 00:02:12,500
存储服务封装了所有数据处理细节

58
00:02:12,500 --> 00:02:15,500
业务应用端代码只关注业务处理逻辑

59
00:02:15,500 --> 00:02:16,500
系统的隔离性更加

60
00:02:16,500 --> 00:02:18,500
另外进行些操作时

61
00:02:18,500 --> 00:02:19,500
如果Cache中没有数据

62
00:02:19,500 --> 00:02:20,500
则不更新

63
00:02:20,500 --> 00:02:21,500
有数据才更新

64
00:02:21,500 --> 00:02:22,500
内存效率更高

65
00:02:22,500 --> 00:02:24,500
微博Feed的Outbox Vector

66
00:02:24,500 --> 00:02:26,500
及用户最新微博列表

67
00:02:26,500 --> 00:02:27,500
就采用这种模式

68
00:02:27,500 --> 00:02:29,500
一些粉丝数较少

69
00:02:29,500 --> 00:02:31,500
且不活跃的用户发表微博后

70
00:02:31,500 --> 00:02:34,500
Vector服务首先会查询Vector Cache

71
00:02:34,500 --> 00:02:37,500
如果Cache中没有该用户的Outbox记录

72
00:02:37,500 --> 00:02:39,500
则不写用户的Cache数据

73
00:02:39,500 --> 00:02:41,500
直接更新DB就直接返回

74
00:02:41,500 --> 00:02:42,500
如果Cache中存在

75
00:02:42,500 --> 00:02:45,500
则会通过Cache指令进行更新

76
00:02:45,500 --> 00:02:47,500
RedBin的开信模式

77
00:02:47,500 --> 00:02:48,500
与RedRed Thru模式类似

78
00:02:48,500 --> 00:02:50,500
也由数据存储服务来管理

79
00:02:50,500 --> 00:02:52,500
开启个DB的读写

80
00:02:52,500 --> 00:02:53,500
不同点是

81
00:02:53,500 --> 00:02:54,500
数据更新时

82
00:02:54,500 --> 00:02:57,500
RedRed Thru是同步更新开启个DB

83
00:02:57,500 --> 00:03:00,500
而RedBin的开信则是只更新缓冲

84
00:03:00,500 --> 00:03:01,500
不直接更新DB

85
00:03:01,500 --> 00:03:05,500
而是改用异步批量的方式来更新DB

86
00:03:05,500 --> 00:03:06,500
该模式的特点是

87
00:03:06,500 --> 00:03:08,500
数据存储的写信能非常高

88
00:03:08,500 --> 00:03:09,500
非常适合一些

89
00:03:09,500 --> 00:03:11,500
变更特别频繁的业务

90
00:03:11,500 --> 00:03:13,500
特别是可以合并写信求的业务

91
00:03:13,500 --> 00:03:15,500
比如针对一些技术业务

92
00:03:15,500 --> 00:03:17,500
一条Feed被点赞一万次

93
00:03:17,500 --> 00:03:19,500
如果更新一万次DB代价很大

94
00:03:19,500 --> 00:03:22,500
而合并成一条请求直接加一万

95
00:03:22,500 --> 00:03:24,500
则是一个非常轻量的操作

96
00:03:24,500 --> 00:03:26,500
但这种模型有一个显著特点

97
00:03:26,500 --> 00:03:28,500
即数据的意志性变差

98
00:03:28,500 --> 00:03:29,500
甚至在一些极端场景下

99
00:03:29,500 --> 00:03:31,500
可能会丢数据

100
00:03:31,500 --> 00:03:32,500
比如系统crash

101
00:03:32,500 --> 00:03:33,500
机械当机

102
00:03:33,500 --> 00:03:35,500
如果数据还没有保存到DB

103
00:03:35,500 --> 00:03:36,500
则会存在丢失的风险

104
00:03:36,500 --> 00:03:38,500
所以这种读写模式

105
00:03:38,500 --> 00:03:40,500
非常适合变更频率特别高

106
00:03:40,500 --> 00:03:42,500
但对意志性要求不太高的业务

107
00:03:42,500 --> 00:03:43,500
这样写操作

108
00:03:43,500 --> 00:03:45,500
可以异步批量写入DB

109
00:03:45,500 --> 00:03:46,500
减少DB压力

110
00:03:46,500 --> 00:03:47,500
讲到这里

111
00:03:47,500 --> 00:03:49,500
缓存的三种读写模式讲完了

112
00:03:49,500 --> 00:03:50,500
你可以看到

113
00:03:50,500 --> 00:03:51,500
三种模式各有优劣

114
00:03:51,500 --> 00:03:53,500
不存在最佳方案

115
00:03:53,500 --> 00:03:54,500
实际上我们也不可能

116
00:03:54,500 --> 00:03:56,500
设计出一个最佳完美模式出来

117
00:03:56,500 --> 00:03:59,500
如同前面讲到的空间换时间

118
00:03:59,500 --> 00:04:01,500
访问延迟换成本一样

119
00:04:01,500 --> 00:04:02,500
高性能和强意志性

120
00:04:02,500 --> 00:04:04,500
从来都是冲突的

121
00:04:04,500 --> 00:04:05,500
系统设计从来就是取舍

122
00:04:05,500 --> 00:04:07,500
随处需要tradeoff

123
00:04:07,500 --> 00:04:09,500
这个思想会贯穿整个课程

124
00:04:09,500 --> 00:04:11,500
这也许是我们学习这个课程的

125
00:04:11,500 --> 00:04:12,500
另外一个收获

126
00:04:12,500 --> 00:04:13,500
即如何根据业务场景

127
00:04:13,500 --> 00:04:14,500
更好地做tradeoff

128
00:04:14,500 --> 00:04:16,500
从而设计出更好的服务系统

129
00:04:16,500 --> 00:04:18,500
前面介绍了缓存的基本思想

130
00:04:18,500 --> 00:04:21,500
优势 代价 以及读写模式

131
00:04:21,500 --> 00:04:22,500
接下来我们一起看一下

132
00:04:22,500 --> 00:04:24,500
互联网企业常用的缓存

133
00:04:24,500 --> 00:04:25,500
有哪些分类

134
00:04:25,500 --> 00:04:27,500
按宿主层次分类的话

135
00:04:27,500 --> 00:04:29,500
缓存一般可以分为

136
00:04:29,500 --> 00:04:31,500
本地cache 进程间cache

137
00:04:31,500 --> 00:04:32,500
和远程cache

138
00:04:32,500 --> 00:04:33,500
本地cache是指

139
00:04:33,500 --> 00:04:35,500
业务进程类的缓存

140
00:04:35,500 --> 00:04:37,500
这类缓存由于在

141
00:04:37,500 --> 00:04:38,500
业务系统进程类

142
00:04:38,500 --> 00:04:40,500
所以读写性能超高

143
00:04:40,500 --> 00:04:42,500
而且没有任何网络开销

144
00:04:42,500 --> 00:04:43,500
但不足是会随着

145
00:04:43,500 --> 00:04:45,500
业务系统存起来丢失

146
00:04:45,500 --> 00:04:46,500
进程间cache

147
00:04:46,500 --> 00:04:48,500
是本机独立运行的缓存

148
00:04:48,500 --> 00:04:50,500
这类缓存读写性能较高

149
00:04:50,500 --> 00:04:51,500
不会随着业务系统

150
00:04:51,500 --> 00:04:53,500
存起丢失数据

151
00:04:53,500 --> 00:04:55,500
而且可以大幅减少网络开销

152
00:04:55,500 --> 00:04:57,500
但不足是业务系统和缓存

153
00:04:57,500 --> 00:04:58,500
都在相同宿主机

154
00:04:58,500 --> 00:04:59,500
因为复杂

155
00:04:59,500 --> 00:05:00,500
且存在资源竞争

156
00:05:00,500 --> 00:05:02,500
远程cache是指

157
00:05:02,500 --> 00:05:04,500
跨机器部署的缓存

158
00:05:04,500 --> 00:05:06,500
这类缓存因为独立设备部署

159
00:05:06,500 --> 00:05:07,500
容量大且易扩展

160
00:05:07,500 --> 00:05:09,500
在互联网企业应用最广泛

161
00:05:09,500 --> 00:05:12,500
不过远程缓存需要跨机访问

162
00:05:12,500 --> 00:05:13,500
在高读写压力下

163
00:05:13,500 --> 00:05:15,500
带宽容易成为瓶颈

164
00:05:15,500 --> 00:05:17,500
本地cache的缓存组件有

165
00:05:17,500 --> 00:05:19,500
EHcache,GrowerCache

166
00:05:19,500 --> 00:05:20,500
开发者自己也可以用

167
00:05:20,500 --> 00:05:21,500
MapSet等

168
00:05:21,500 --> 00:05:22,500
轻松构建一个

169
00:05:22,500 --> 00:05:24,500
自己专用的本地cache

170
00:05:24,500 --> 00:05:26,500
进程间cache和远程cache的

171
00:05:26,500 --> 00:05:27,500
缓存组件相同

172
00:05:27,500 --> 00:05:29,500
只是部署位置差异罢了

173
00:05:29,500 --> 00:05:30,500
这类缓存组件有

174
00:05:30,500 --> 00:05:33,500
Memcache,Radius,Pica等

175
00:05:33,500 --> 00:05:35,500
还有一种常见的分类方式

176
00:05:35,500 --> 00:05:37,500
是按存储机制来分类

177
00:05:37,500 --> 00:05:38,500
这样可以分为

178
00:05:38,500 --> 00:05:40,500
内存型缓存和持久化型缓存

179
00:05:40,500 --> 00:05:42,500
内存型缓存将数据存在内存

180
00:05:42,500 --> 00:05:43,500
读写性能很高

181
00:05:43,500 --> 00:05:46,500
但缓存系统存起和Crush后

182
00:05:46,500 --> 00:05:48,500
内存数据会丢失

183
00:05:48,500 --> 00:05:49,500
持久化型缓存将数据

184
00:05:49,500 --> 00:05:51,500
存储到SSD硬盘中

185
00:05:51,500 --> 00:05:52,500
相同成本下

186
00:05:52,500 --> 00:05:54,500
这种缓存的容量会比

187
00:05:54,500 --> 00:05:56,500
内存型缓存大一个数量级以上

188
00:05:56,500 --> 00:05:58,500
而且数据会持久化落地

189
00:05:58,500 --> 00:05:59,500
存起不丢失

190
00:05:59,500 --> 00:06:01,500
但读写性能相对低

191
00:06:01,500 --> 00:06:03,500
一到两个数量级

192
00:06:03,500 --> 00:06:05,500
Memcache是典型的内存型缓存

193
00:06:05,500 --> 00:06:07,500
而Pica以及其他基于

194
00:06:07,500 --> 00:06:09,500
RoxDB开发的缓存组件

195
00:06:09,500 --> 00:06:11,500
则属于持久化型缓存

196
00:06:11,500 --> 00:06:13,500
至此缓存原理相关的知识点就讲完了

197
00:06:13,500 --> 00:06:15,500
接下来会讲到

198
00:06:15,500 --> 00:06:17,500
如何引入缓存并进行设计架构

199
00:06:17,500 --> 00:06:19,500
以及缓存在设计架构中的一些

200
00:06:19,500 --> 00:06:21,500
关键考量点

201
00:06:21,500 --> 00:06:23,500
OK 这节课就讲到这里

202
00:06:23,500 --> 00:06:25,500
下一课时我会分享缓存的

203
00:06:25,500 --> 00:06:27,500
引入及架构设计

204
00:06:27,500 --> 00:06:28,500
记得按时来听课哈

205
00:06:28,500 --> 00:06:30,500
下节课见 拜拜

